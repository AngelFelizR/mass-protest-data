---
title: "Analizing Protests from 1990 to 2020"
author: "Angel Feliz"
date: "`r format(Sys.Date(),'%d %B %Y')`"
output: 
  html_document:
    css: styles.css
    highlight: tango
    theme: united
    toc: true
    toc_float:
      collapsed: false
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, 
                      fig.align = "center", fig.dim = c(12,8))
```

# Introduction

Protests are an important part of society change. In this post we are going to explore data from **The Mass Mobilization Project** which contains information about protests against governments, and contains a variety of variables such as location, dates and number of participants. The data was obtained by this [link](https://github.com/datacamp/careerhub-data/tree/master/Mass%20Protest%20Data)

This data opens the possibility to understand:

1. How does the number of protests change over time?
2. Why do people protests?
3. Who do States respond to the protests?

To answer those questions we will perform an **Exploratory Data Analysis (EDA)** applying the next skills:

- R (functional) programming with **base R**
- Missing values exploration with **naniar**
- Data manipulation with **data.table**, **lubridate** and **stringr**
- Static data visualization with **ggplot2**, **scales**, **forcats** and **patchwork**
- Network visualization with **igraph** and **ggraph**
- Interactive data visualization with **plotly** and **crosstalk**
- Automated reporting with **rmarkdown**, **flextable**, **html** and **css**
- Text mining with **tidytext**

</br>

# 1. Enveroment set-up

The first step to perform our analysis is to define all the functions and vectors
that we will use during the projects. To make that possible we will follow the next
steps:

</br>

1. Libraries and data importation.

```{r libraries}

library(data.table)
library(lubridate)
library(stringr)
library(countrycode)
library(naniar)
library(flextable)
library(ggplot2)
library(scales)
library(forcats)
library(patchwork)
library(igraph)
library(ggraph)
library(plotly)
library(crosstalk)

theme_set(theme_light())

ProtestRaw <-
  fread("Raw-data/protest_data.csv", na.strings = "", integer64 = "double")

```

</br>

2. Defining useful vectors to clean data.

```{r fixed-vectors}

# It helps to complete continent definition 
EuropeMissingCountries <-  
c("Yugoslavia", "Serbia and Montenegro",
  "Kosovo","Germany East","Czechoslovakia")

```

</br>

3. Defining custom functions to avoid repeating many times the same code.

```{r custom-function}

# We will use this style to show data frames.

style_table <- function(DATA){
  
  DATA |>
  flextable() |>
  border_remove() |>
  bg(bg = "#008000", part = "header") |>
  bold(part = "header") |>
  color(color = "white", part = "header") |>
  border_inner_h(border = officer::fp_border(color = "#dddddd")) |>
  bg(i = 1:nrow(DATA) %% 2 == 0, bg = "#f3f3f3") |>
  autofit()
  
}


# Creates a bar plot by counting unique number of id_var 
# for categories included in group_var and plot_fill_var. 
# plot_fill_var is used to fill the bars.

plot_chr_count <- function(DATA,
                           id_var,
                           group_var,
                           plot_fill_var,
                           plot_fill,
                           plot_title,
                           plot_max,
                           use_cumulative_sum = TRUE){

  
  if(missing(plot_fill_var)){
    group_vector <- "group"
  }else{
    group_vector <- c("group",plot_fill_var)
  }
  
  
  data_summary <-
    DATA[, setnames(.SD, c(id_var,group_var), c("id","group"))
    ][, .(number_protest = uniqueN(id)), group_vector
    ][order(-number_protest)
    ][, group := as_factor(group)
    ][, pct := fifelse(rep(use_cumulative_sum, .N), 
                       cumsum(number_protest), number_protest) /
               sum(number_protest)]
  
  
  # Filtering top categories
  
  if(!missing(plot_max) && !nrow(data_summary) <= plot_max){
    data_summary <- data_summary[1:plot_max]
  }
  
  
  # Defining data plot and plot title 
  
  if(missing(plot_fill_var) & missing(plot_fill)){
    
    base_aes <- 
      ggplot(data_summary,aes(number_protest, fct_rev(group))) +
      geom_col(aes(fill = group))
    
    fill_title <- str_to_sentence(group_var)
    
  }else if(!missing(plot_fill)){
    
    base_aes <-
      ggplot(data_summary,aes(number_protest, fct_rev(group))) +
      geom_col(fill = plot_fill)
    
    fill_title <- ""
    
  }else{
    
    data_summary[, plot_fill_var := get(plot_fill_var)]
    base_aes <-
      ggplot(data_summary,aes(number_protest, fct_rev(group))) +
      geom_col(aes(fill = plot_fill_var))
    
    fill_title <-str_to_sentence(plot_fill_var)
    
  }
  

  # Applying theme customization
  
  base_aes +
    geom_text(aes(label = percent(pct, accuracy = 0.1)),
              hjust = -0.3, size = 6)+
    geom_blank(aes(x = number_protest *1.08))+
    scale_x_continuous(labels = comma_format(accuracy = 1))+
    labs(title = plot_title, x = "", y = "", fill = fill_title)+
    theme(plot.title = element_text(color = "black", face = "bold", 
                                    size = 22, hjust = 0.5),
          legend.position = "top",
          legend.title = element_text(color = "black",size = 16),
          legend.text = element_text(color = "black",size = 14),
          axis.title = element_text(color = "black", face = "bold", 
                                    size = 18),
          axis.text = element_text(color = "black", size = 16),
          strip.text = element_text(face = "bold",size = 14),
          panel.grid.major.y = element_blank())
  
}

```

</br>

# 2. Tidying data

As most data in the world this data needs some transformations facilitate it's
exploration.

</br>

## 2.1. Data quality exploration

To start this process, let's summary the influence of `protest` variable across
the missing values in each variable.

```{r , fig.dim = c(14,10)}

RowProtestProportion_plot <-
ProtestRaw[, .(`Number of rows` = .N / max(.I)), 
           .(protest = fifelse(protest>0,"Protest","No Protest"))] |>
  ggplot(aes("Protest", `Number of rows`))+
  geom_col(aes(fill= protest))+
  geom_text(aes(label = percent(`Number of rows`)), 
            position = position_stack(vjust = 0.5), 
            fontface = "bold", size = 7)+
  scale_fill_manual(values = c("No Protest" = "gray80", 
                               "Protest" = "seagreen"))+
  coord_polar(theta = "y")+
  labs(title = "Propotion of rows that\nrepresent a protest", fill = "") +
  theme_void()+
  theme(legend.position = "top",
        plot.title = element_text(face = "bold", size = 25,
                                  hjust = 0.5, margin = margin(b = 40)),
        legend.text = element_text(size = 18))


MissingVar_plot <-
copy(ProtestRaw)[,protest := fifelse(protest>0,"Protest","No Protest")]|>
  gg_miss_var( facet = protest, show_pct = TRUE)+
  labs(title = "Proportions of missing\nvalues per variable")+
  theme(axis.text = element_text(size = 15),
        axis.title = element_text(size = 16, face = "bold"),
        strip.text = element_text(size = 16),
        plot.title = element_text(size = 25, face = "bold",
                                  hjust = 0.5, margin = margin(b = 40)))


RowProtestProportion_plot + MissingVar_plot

```
</br>

By checking the last chart we can see that:

</br>

**Problem 1:** Only **`r percent(ProtestRaw[, mean(protest == 0)], accuracy = 1)` rows** in the data represent a country and year where there wasn't protest recorded.
Rows without protests have to many missing values and it makes same, as most of 
the variables in data give information assuming there were a protest.

**Solution:** We will take out all the rows that don't have protest related. 

</br>

**Problem 2:** Protests' start and end days are split in days, months and years columns. With that format it will hard to explore the data properly.

**Solution:** We will join days, months and years to create the `start_date` and 
`end_date` variables as Date columns.

</br>

**Problem 3:** `participants_category` is a categorical variable with **`r ProtestRaw[protest == 1, uniqueN(participants_category)] |> comma()` unique values**, but it has too many missing values.

**Solution:** We will use `participants` variable to complete `participants_category`'s values. 

`participants` is also a categorical variable with **`r ProtestRaw[, uniqueN(participants)] |> comma()` unique values**, but only **`r ProtestRaw[protest == 1, mean(is.na(participants))] |> percent(accuracy = 0.01)` of its rows** are missing. Bellow we can see some examples of how 
`participants_category` and `participants` are related.

```{r}
set.seed(14)

copy(ProtestRaw)[is.na(`participants_category`) & 
                   !is.na(`participants`) &
                   str_detect(participants,"[:symbol:]|-"), 
                 case_type := 1
  ][!is.na(`participants_category`) & 
      !is.na(`participants`) &
      !participants %like% "\\d",
    case_type := 2
  ][!is.na(case_type),
    .(id = as.character(id), country, year = as.character(year),
      `participants_category`, `participants`, case_type)
  ][, .SD[sample.int(.N,5)], case_type
  ][, !c("case_type")] |>
  style_table()

```

As we can see `participants` can have only words, number of number ranges almost
all related to indicate the number of participants in each protest, but is less
exact than `participants_category`, the best alternative is to complete the missing
values of `participants_category` based on `participants`.

</br>

**Problem 4:** Protester demands and states responses are stored across many columns. That format creates many missing values and makes hard to explore the data.

**Solution:** We will reshape the data to have just 3 columns. 
  - `action_source`: Defines if the action was made by protesters or the state.
  - `actions`: Stores the values stored in the current columns.
  - `action_occur`: Defines whether an action took place in a particular protest.
  
</br>

## 2.2. Data tidying process

The next script will solve **Problem 1** and **Problem 2**, and save the result
as `ProtestFilteredWithDates`.

```{r}

ProtestFilteredWithDates <-
  
  # Problem 1: Keeping rows related to a protest
  ProtestRaw[protest == 1, !c("protest")
        
  # Problem 2: Joining days, months and years
  ][, `:=`(start_date =  
             paste(startyear,startmonth,startday,sep = "-") |> ymd(),
           end_date =  
             paste(endyear,endmonth,endday,sep = "-") |> ymd())
  ][, .SD, .SDcols = !patterns("\\w+year$|\\w+month$|\\w+day$")]

```

</br>

The next script will solve **Problem 3** and save the result as `ProtestClean`.

```{r data-wrangling}

ProtestClean <-
  
  # Let's work only with protests that are missing participants_category
ProtestFilteredWithDates[is.na(participants_category)
    
  # Applying general cleaning to participants
  ][,participants := participants |>  
                      str_to_lower() |> 
                      str_remove_all(",") |>
                      str_replace_all(" +"," ")
    
  # Getting the average of participants intervals
  ][, c("min","max") := tstrsplit(participants,"-| to ", fixed = FALSE)
  ][participants %like% "between \\d+ and \\d+", 
    `:=`(min = str_match(participants, "between (\\d+) and \\d+")[,2],
         max = str_match(participants, "between \\d+ and (\\d+)")[,2])
  ][, c("min","max") := lapply(.(min, max), 
                               function(x) str_extract(x, "\\d+") |> 
                                            as.double())
  ][, participants_clean := (min+max)/2
  ][, !c("min","max")
    
  # Getting number of protesters by using regular expressions
  ][participants %like% "^\\d+$" & is.na(participants_clean),
    participants_clean := as.double(participants)
  ][participants %like% "^\\d+\\+$" & is.na(participants_clean),
    participants_clean := str_remove_all(participants,"\\+") |> as.double()
  ][participants %like% "^\\d+s" & is.na(participants_clean),
    participants_clean := str_match(participants,"^(\\d+)s")[,2] |>  as.double()
  ][participants %like% "^[><]\\d+" & is.na(participants_clean),
    participants_clean := str_match(participants,"^[><](\\d+)")[,2] |> as.double()
    
  # Getting number of protesters by reading the notes variable
  ][id == 922006004, 
    participants_clean := 50
  ][id == 6602002005, 
    participants_clean := 2000
  
  # Creating a new participants_category variable
  ][, participants_category := 
      fcase( between(participants_clean, 1, 99), "1-99",
             between(participants_clean, 100, 999), "100-999",
             between(participants_clean, 1000, 1999), "1000-1999",
             between(participants_clean, 2000, 4999), "2000-4999",
             between(participants_clean, 5000, 10000), "5000-10000",
             participants_clean > 10000, ">10000",
             default = "Missing")
  ][, !c("participants_clean")
    
  # Adding protests that aren't missing participants_category  
  ][, rbind(.SD,ProtestFilteredWithDates[!is.na(participants_category)])
    
  # Making participants_category a factor variable 
  #to make easier to plot the data later
  ][participants_category == "50-99",
    participants_category := "1-99"
  ][, participants_range := factor(participants_category,
                                  levels = c("Missing",   "1-99",     
                                             "100-999",   "1000-1999", 
                                             "2000-4999", "5000-10000",
                                             ">10000"))
  ][, !c("participants","participants_category")]

```

</br>

After cleaning the variables we are ready to reshape the data to a longer format
and solve the **problem 4**.

```{r}

ProtestCleanTidy <-
  
  # Melting protesterdemand and stateresponse just keeping protest id
ProtestClean[, melt(.SD, 
                    id.vars = "id",
                    measure.vars = str_subset(names(.SD),
                                              "^protesterdemand|^stateresponse"),
                    value.name = "actions",
                    variable.factor = FALSE)
  ][!is.na(actions) & actions %like% "\\w"
  ][, variable := fifelse(variable %like% "^protesterdemand", 
                          "protester_demand","state_response")
    
  # Taking out any duplicated answer stored in protesterdemand or stateresponse
  ][, unique(.SD)
    
  # Adding ids that don't have either protester_demand or state_response
  # and adding actions that didn't happen in each protest
  ][, `:=` (action_occur = TRUE,
            actions = str_c(variable," - ",actions))
  ][, !c("variable")
  ][, merge(.SD,
            CJ(id = unique(ProtestClean$id),
               actions = unique(actions)),
            by = c("id", "actions"), all = TRUE)
  ][is.na(action_occur), action_occur := FALSE
  ][, c("action_source", "actions") := tstrsplit(actions, split = " - ", fixed = TRUE)
    
  # Adding the other variables to have back the data complete
  ][, merge(.SD, ProtestClean, by = "id", all = TRUE)
  ][, .SD, .SDcols = !patterns("^protesterdemand|^stateresponse")]

```

</br>

## 2.3. Result


```{r}

set.seed(14)

ProtestCleanTidy[id == sample(id, 1), 
                 .(id = as.character(id), 
                   country, participants_range, 
                   start_date = format(start_date,"%m/%d/%y"),
                   end_date = format(end_date,"%m/%d/%y"),
                   action_source, actions, action_occur)] |>
  style_table()

```


```{r}

ProtestCleanTidy |>
  gg_miss_upset()

ProtestCleanTidy |>
  gg_miss_var()+
  labs(title = "Proportions of missing\nvalues per variable")+
  theme(axis.text = element_text(size = 15),
        axis.title = element_text(size = 16, face = "bold"),
        strip.text = element_text(size = 16),
        plot.title = element_text(size = 25, face = "bold",
                                  hjust = 0.5, margin = margin(b = 40)))


```


# 3. Adding new variables

```{r include=FALSE}
ProtestCleanTidy <- 
  ProtestCleanTidy[!country %chin% EuropeMissingCountries, 
                   continent := countrycode(country, 
                                            origin = "country.name",
                                            destination = "continent")
  ][country %chin% EuropeMissingCountries, continent := "Europe"]


```


# 2. Data exploration


## 2.1. Which country have more protests?

In next chart we can see that the countries with more protests comes from Europe. Together, they sum 12.6% of protest in the data. Let's focus in those countries and try to answer some questions.

```{r}

plot_chr_count(DATA = ProtestCleanTidy,
               id_var = "id",
               group_var = "country",
               plot_fill_var = "continent",
               plot_title = "Top 20 of Coutries with more Protests",
               plot_max = 20,
               use_cumulative_sum = TRUE)
```

## 2.2. UK Graph Analysis

```{r, fig.dim = c(14,10)}

UKEdges <-
  ProtestCleanTidy[action_occur == TRUE & action_source == "protester_demand"
  ][, setnames(.SD, "actions", "from")
  ][ProtestCleanTidy[action_occur == TRUE & action_source == "state_response",
                     .(to = actions), id],
    on = .(id)
  ][country == "United Kingdom", 
    .(number_protests = uniqueN(id)),
    .(from,to)
  ][,unique(.SD)]

UKNodes <-
ProtestCleanTidy[country == "United Kingdom" & action_occur == TRUE,
                 .(actions,action_source)
  ][, unique(.SD)]


UKgraph <- graph_from_data_frame(d = UKEdges, vertices = UKNodes)

set.seed(1)

ggraph(UKgraph, layout = "with_fr")+
  geom_edge_link(aes(alpha = number_protests,edge_width = number_protests))+
  geom_node_point(aes(color = action_source), size = 8)+
  geom_node_text(aes(label = name), vjust = 2, size = 6)+
  scale_color_brewer(palette = "Dark2")+
  labs(title = "Graph of UK Protests")+
  theme_void()+
  theme(legend.position = "left",
        legend.title = element_text(face = "bold", size = 15),
        legend.text = element_text(size = 15),
        plot.title = element_text(face = "bold", size = 20, hjust = 0.5))

```

# 3. More plots

```{r, fig.dim = c(14,10)}

plot_chr_count(DATA = ProtestCleanTidy,
               id_var = "id",
               group_var = "country",
               plot_fill_var = "continent",
               plot_title = "Total of protests per country",
               plot_max = 40,
               use_cumulative_sum = FALSE)+
  labs(subtitle = " ")+
  facet_wrap(~continent, scales = "free_y")+
  theme(legend.position = "none")

```


As we can see in the chart most of the protests occurs in **`r levels(ProtestCleanTidy$continent)[1]`** and  **`r levels(ProtestCleanTidy$continent)[2]`**.

As this data have information of protests between *`r ProtestCleanTidy[, min(year)]`* and *`r ProtestCleanTidy[, max(year)]`* let's see how the number of protests change each year for each continent.

```{r, fig.align='center', fig.dim = c(10,6)}

continent_count_year_plot <-
ProtestCleanTidy[, .(number_protest = uniqueN(id)),
                  .(continent, year)] |>
  SharedData$new(key = ~continent, group = "Select a continent") |>
  ggplot(aes(year, number_protest, color = continent))+
  geom_line(size = 1)+
  geom_point(size = 2)+
  scale_y_continuous(breaks = breaks_width(50))+
  scale_x_continuous(breaks = breaks_width(2))+
  labs(title = "Number of Protests per Continent and Year",
       x = "Year", y = "Number of Protests", color = "Continent")+
  theme(plot.title = element_text(color = "black", face = "bold"))

  ggplotly(continent_count_year_plot) |>
    highlight(on = 'plotly_click',
              off = 'plotly_doubleclick')

```

At first view, we can see that *2020* isn't a normal year as countries have less protests that year than any other year in the past. That abnormality makes sense when we check that he last date in data is ***`r ProtestCleanTidy[,max(c(start_date,end_date))] |> format("%m/%d/%y")`***.

Checking each individual Continent by clicking over each one we can see:

- **Europe:** Only *`r continent_count_year_plot$data[continent == "Europe",  mean(number_protest > 150)|> percent()]`* of years have more than 150 per year and would be interesting to under why was the people protesting in **1990**, **1996-1997** and **2013-2019**.

- **Asia:** The number of protests per year increased from less than 100 protests per year to 159 between **1997 and 2000**, then between **2005 and 2006** and 3 high picks in **2011**, **2014** and **2019**.

- **Africa:** The number of protest had a pick in **2005**, an increase tendency between **2010 and 2012**, two important picks in **2015** and **2019**.

- **America:** It has to important picks in **2015** and **2019**.

- **Oceania:** It just have two picks of 5 protest in **2001** and **2005**.

```{r, fig.align='center', fig.dim = c(10,6)}

ProtestCleanTidy[continent == "Europe", 
                  .(number_protest = uniqueN(id)),
                  .( country, year)] |>
  ggplot(aes(number_protest))+
  geom_histogram(bins = 20)+
  scale_x_log10(breaks = 2^(1:7) |> round())


EUR_count_year_plot <-
ProtestCleanTidy[continent == "Europe", 
                  .(number_protest = uniqueN(id)),
                  .( country, year)
  ][, number_protest_max := max(number_protest), country
  ][number_protest_max >= 30] |>
  SharedData$new(key = ~country, group = "Select a continent") |>
  ggplot(aes(year, number_protest, color = country))+
  geom_line(size = 1)+
  geom_point(size = 2)+
  scale_y_continuous(breaks = breaks_width(10))+
  scale_x_continuous(breaks = breaks_width(2))+
  labs(title = "Number of Protests per Country and Year",
       x = "Year", y = "Number of Protests", color = "Continent")+
  theme(plot.title = element_text(color = "black", face = "bold"))

  ggplotly(EUR_count_year_plot) |>
    highlight(on = 'plotly_click',
              off = 'plotly_doubleclick')

```