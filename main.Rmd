---
title: "Analizing Protests from 1990 to 2020"
author: "Angel Feliz"
date: "`r format(Sys.Date(),'%d %B %Y')`"
output: 
  html_document:
    css: styles.css
    highlight: tango
    theme: united
    toc: true
    toc_float:
      collapsed: false
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, 
                      fig.align = "center", fig.dim = c(12,8))
```

# Introduction

Protests are an important part of society change. In this post we are going to explore data from **The Mass Mobilization Project** which contains information about protests against governments, and contains a variety of variables such as location, dates and number of participants. The data was obtained by this [link](https://github.com/datacamp/careerhub-data/tree/master/Mass%20Protest%20Data)

This data opens the possibility to understand:

1. How does the number of protests change over time?
2. Why do people protests?
3. Who do states respond to the protests?

To answer those questions we will perform an **Exploratory Data Analysis (EDA)** applying the next skills:

- R (functional) programming with **base R**
- Web scraping with **rvest**
- Data manipulation with **data.table**, **lubridate** and **stringr**
- Static data visualization with **ggplot2**, **scales**, **forcats** and **patchwork**
- Network visualization with **igraph** and **ggraph**
- Interactive data visualization with **plotly** and **crosstalk**
- Automated reporting with **rmarkdown**, **flextable**, **html** and **css**
- Text mining with **tidytext**

</br>

# 1. Enveroment set-up

To set up the environment we will use to create the report we just need to follow the next steps:

</br>

1. Libraries and data importation.

```{r libraries}
# If you want to reproduce this analysis you can use the same version
# of the packages I used by running the flowing code once:
#
#  if(!require(renv)) install.packages("renv")
#  renv::status()
#  renv::restore()

library(data.table)
library(lubridate)
library(stringr)
library(countrycode)
library(flextable)
library(ggplot2)
library(scales)
library(forcats)
library(patchwork)
library(igraph)
library(ggraph)
library(plotly)
library(crosstalk)
library(ggcorrplot)
library(correlation)
library(see)
library(rvest)

theme_set(theme_light())

ProtestRaw <-
  fread("Raw-data/protest_data.csv", na.strings = "", integer64 = "double")

```

</br>

2. Defining custom functions to avoid repeating many times the same code.

```{r custom-function}

# We will use this style to show data frames.

style_table <- function(DATA){
  
  DATA |>
  flextable() |>
  border_remove() |>
  bg(bg = "#008000", part = "header") |>
  bold(part = "header") |>
  color(color = "white", part = "header") |>
  border_inner_h(border = officer::fp_border(color = "#dddddd")) |>
  bg(i = 1:nrow(DATA) %% 2 == 0, bg = "#f3f3f3") |>
  autofit()
  
}

# We will use function to read some csv files
# with information from World Bank

read_country_index <- function(path){
  
  fread(path,
        header = TRUE, skip = 2, 
        drop = c("Indicator Code","Country Code")
  )[, lapply(.SD, function(x) if(is.integer(x)){as.double(x)}else{x})
  ][, melt(.SD, 
           id.vars = c("Country Name","Indicator Name"),
           variable.factor = FALSE,
           na.rm = TRUE,
           value.name = "Index", variable.name = "Year"),
    .SDcols = !is.logical]
  
}


# Creates a bar plot by counting unique number of id_var 
# for categories included in group_var and plot_fill_var. 
# plot_fill_var is used to fill the bars.

plot_chr_count <- function(DATA,
                           id_var,
                           group_var,
                           plot_fill_var,
                           plot_fill,
                           plot_title,
                           plot_max,
                           use_cumulative_sum = TRUE){

  
  if(missing(plot_fill_var)){
    group_vector <- "group"
  }else{
    group_vector <- c("group",plot_fill_var)
  }
  
  
  data_summary <-
    DATA[, setnames(.SD, c(id_var,group_var), c("id","group"))
    ][, .(number_protest = uniqueN(id)), group_vector
    ][order(-number_protest)
    ][, group := as_factor(group)
    ][, pct := fifelse(rep(use_cumulative_sum, .N), 
                       cumsum(number_protest), number_protest) /
               sum(number_protest)]
  
  
  # Filtering top categories
  
  if(!missing(plot_max) && !nrow(data_summary) <= plot_max){
    data_summary <- data_summary[1:plot_max]
  }
  
  
  # Defining data plot and plot title 
  
  if(missing(plot_fill_var) & missing(plot_fill)){
    
    base_aes <- 
      ggplot(data_summary,aes(number_protest, fct_rev(group))) +
      geom_col(aes(fill = group))
    
    fill_title <- str_to_sentence(group_var)
    
  }else if(!missing(plot_fill)){
    
    base_aes <-
      ggplot(data_summary,aes(number_protest, fct_rev(group))) +
      geom_col(fill = plot_fill)
    
    fill_title <- ""
    
  }else{
    
    data_summary[, plot_fill_var := get(plot_fill_var)]
    base_aes <-
      ggplot(data_summary,aes(number_protest, fct_rev(group))) +
      geom_col(aes(fill = plot_fill_var))
    
    fill_title <-str_to_sentence(plot_fill_var)
    
  }
  

  # Applying theme customization
  
  base_aes +
    geom_text(aes(label = percent(pct, accuracy = 0.1)),
              hjust = -0.3, size = 6)+
    geom_blank(aes(x = number_protest *1.08))+
    scale_x_continuous(labels = comma_format(accuracy = 1))+
    labs(title = plot_title, x = "", y = "", fill = fill_title)+
    theme(plot.title = element_text(color = "black", face = "bold", 
                                    size = 22, hjust = 0.5),
          legend.position = "top",
          legend.title = element_text(color = "black",size = 16),
          legend.text = element_text(color = "black",size = 14),
          axis.title = element_text(color = "black", face = "bold", 
                                    size = 18),
          axis.text = element_text(color = "black", size = 16),
          strip.text = element_text(face = "bold",size = 14),
          panel.grid.major.y = element_blank())
  
}

```

</br>

# 2. Tidying data

As most data in the world this data needs some transformations facilitate it's exploration.

</br>

## 2.1. Data quality evaluation

To start this process, let's summary the influence of `protest` variable across the missing values in each variable.

```{r , fig.dim = c(14,10)}

RowProtestProportion_plot <-
ProtestRaw[, .(`Number of rows` = .N / max(.I)), 
           .(protest = fifelse(protest>0,"Protest","No Protest"))] |>
  ggplot(aes("Protest", `Number of rows`))+
  geom_col(aes(fill= protest))+
  geom_text(aes(label = percent(`Number of rows`)), 
            position = position_stack(vjust = 0.5), 
            fontface = "bold", size = 7)+
  scale_fill_manual(values = c("No Protest" = "gray80", 
                               "Protest" = "seagreen"))+
  coord_polar(theta = "y")+
  labs(title = "Propotion of rows that\nrepresent a protest", fill = "") +
  theme_void()+
  theme(legend.position = "top",
        plot.title = element_text(face = "bold", size = 25,
                                  hjust = 0.5, margin = margin(b = 40)),
        legend.text = element_text(size = 18))


MissingVar_plot <-
  copy(ProtestRaw)[,protest := fifelse(protest>0,"Protest","No Protest")
  ][, lapply(.SD, function(x) mean(is.na(x))),
    protest
  ][, melt(.SD, id.vars = "protest", 
           variable.name = "Variables",
           value.name = "# Missing")
  ][, `:=`(Variables = fct_reorder(Variables, `# Missing`, sum))] |>
  ggplot(aes(`# Missing`, `Variables`))+
  geom_blank(aes(x = `# Missing` *1.15))+
  geom_col(fill = "seagreen")+
  geom_text(aes(label = percent(`# Missing`, accuracy = 0.01)),
            hjust = -0.3)+
  scale_x_continuous(labels = percent_format(accuracy = 1))+
  facet_wrap(~protest)+
  labs(title = "Proportions of missing\nvalues per variable",
       x = "% Of Missing Values")+
  theme(axis.text = element_text(size = 15),
        axis.title = element_text(size = 16, face = "bold"),
        strip.text = element_text(size = 16, face = "bold"),
        plot.title = element_text(size = 25, face = "bold",
                                  hjust = 0.5, margin = margin(b = 40)))


RowProtestProportion_plot + MissingVar_plot

```
</br>

By checking the last chart we can see that:

</br>

**Problem 1:** Only **`r percent(ProtestRaw[, mean(protest == 0)], accuracy = 1)` rows** in the data represent a country and year where there wasn't protest recorded. Rows without protests have to many missing values and it makes same, as most of  the variables in data give information assuming there were a protest.

**Solution:** We will take out all the rows that don't have protest related. 

</br>

**Problem 2:** Protests' start and end days are split in days, months and years columns. With that format it will hard to explore the data properly.

**Solution:** We will join days, months and years to create the `start_date` and 
`end_date` variables as Date columns.

</br>

**Problem 3:** `participants_category` is a categorical variable with **`r ProtestRaw[protest == 1, uniqueN(participants_category)] |> comma()` unique values**, but it has too many missing values.

**Solution:** We will use `participants` variable to complete `participants_category`'s values. 

`participants` is also a categorical variable with **`r ProtestRaw[, uniqueN(participants)] |> comma()` unique values**, but only **`r ProtestRaw[protest == 1, mean(is.na(participants))] |> percent(accuracy = 0.01)` of its rows** are missing. Bellow we can see some examples of how `participants_category` and `participants` are related.

```{r}
set.seed(14)

copy(ProtestRaw)[is.na(`participants_category`) & 
                   !is.na(`participants`) &
                   str_detect(participants,"[:symbol:]|-"), 
                 case_type := 1
  ][!is.na(`participants_category`) & 
      !is.na(`participants`) &
      !participants %like% "\\d",
    case_type := 2
  ][!is.na(case_type),
    .(id = as.character(id), country, year = as.character(year),
      `participants_category`, `participants`, case_type)
  ][, .SD[sample.int(.N,5)], case_type
  ][, !c("case_type")] |>
  style_table()

```

As we can see `participants` can have only words, number of number ranges almost all related to indicate the number of participants in each protest, but is less exact than `participants_category`, the best alternative is to complete the missing values of `participants_category` based on `participants`.

</br>

**Problem 4:** Protester demands and states responses are stored across many columns. That format creates many missing values and makes hard to explore the data.

**Solution:** We will reshape the data to have just 3 columns. 
  - `action_source`: Defines if the action was made by protesters or the state.
  - `actions`: Stores the values stored in the current columns.
  - `action_occur`: Defines whether an action took place in a particular protest.
  
</br>

## 2.2. Data tidying process

The next script will solve **Problem 1** and **Problem 2**, and save the result
as `ProtestFilteredWithDates`.

```{r}

ProtestFilteredWithDates <-
  
  # Problem 1: Keeping rows related to a protest
  ProtestRaw[protest == 1, !c("protest")
        
  # Problem 2: Joining days, months and years
  ][, `:=`(start_date =  
             paste(startyear,startmonth,startday,sep = "-") |> ymd(),
           end_date =  
             paste(endyear,endmonth,endday,sep = "-") |> ymd())
  ][, .SD, .SDcols = !patterns("\\w+year$|\\w+month$|\\w+day$")]

```

</br>

The next script will solve **Problem 3** and save the result as `ProtestClean`.

```{r data-wrangling}

ProtestClean <-
  
  # Let's work only with protests that are missing participants_category
ProtestFilteredWithDates[is.na(participants_category)
    
  # Applying general cleaning to participants
  ][,participants := participants |>  
                      str_to_lower() |> 
                      str_remove_all(",") |>
                      str_replace_all(" +"," ")
    
  # Getting the average of participants intervals
  ][, c("min","max") := tstrsplit(participants,"-| to ", fixed = FALSE)
  ][participants %like% "between \\d+ and \\d+", 
    `:=`(min = str_match(participants, "between (\\d+) and \\d+")[,2],
         max = str_match(participants, "between \\d+ and (\\d+)")[,2])
  ][, c("min","max") := lapply(.(min, max), 
                               function(x) str_extract(x, "\\d+") |> 
                                            as.double())
  ][, participants_clean := (min+max)/2
  ][, !c("min","max")
    
  # Getting number of protesters by using regular expressions
  ][participants %like% "^\\d+$" & is.na(participants_clean),
    participants_clean := 
      as.double(participants)
  ][participants %like% "^\\d+\\+$" & is.na(participants_clean),
    participants_clean := 
      str_remove_all(participants,"\\+") |> 
      as.double()
  ][participants %like% "^\\d+s" & is.na(participants_clean),
    participants_clean :=
      str_match(participants,"^(\\d+)s")[,2] |>  
      as.double()
  ][participants %like% "^[><]\\d+" & is.na(participants_clean),
    participants_clean := 
      str_match(participants,"^[><](\\d+)")[,2] |>
      as.double()
    
  # Getting number of protesters by reading the notes variable
  ][id == 922006004, 
    participants_clean := 50
  ][id == 6602002005, 
    participants_clean := 2000
  
  # Creating a new participants_category variable
  ][, participants_category := 
      fcase( between(participants_clean, 1, 99), "1-99",
             between(participants_clean, 100, 999), "100-999",
             between(participants_clean, 1000, 1999), "1000-1999",
             between(participants_clean, 2000, 4999), "2000-4999",
             between(participants_clean, 5000, 10000), "5000-10000",
             participants_clean > 10000, ">10000",
             default = "Missing")
  ][, !c("participants_clean")
    
  # Adding protests that aren't missing participants_category  
  ][, rbind(.SD,ProtestFilteredWithDates[!is.na(participants_category)])
    
  # Making participants_category a factor variable 
  #to make easier to plot the data later
  ][participants_category == "50-99",
    participants_category := "1-99"
  ][, participants_range := factor(participants_category,
                                  levels = c("Missing",   "1-99",     
                                             "100-999",   "1000-1999", 
                                             "2000-4999", "5000-10000",
                                             ">10000"))
  ][, !c("participants","participants_category")]

```

</br>

After cleaning the variables we are ready to reshape the data to a longer format and solve the **problem 4**.

```{r}

ProtestCleanTidy <-
  
  # Melting protesterdemand and stateresponse just keeping protest id
  copy(ProtestClean)[, protesterdemand5 := fifelse(protesterviolence == 1 ,"violence",
                                                   NA_character_)
  ][, melt(.SD, 
           id.vars = "id",
           measure.vars = str_subset(names(.SD),
                                     "^protesterdemand|^stateresponse"),
           value.name = "actions",
           variable.factor = FALSE)
  ][!is.na(actions) & actions %like% "\\w"
  ][, variable := fifelse(variable %like% "^protesterdemand", 
                          "protester_demand","state_response")
    
  # Taking out any duplicated answer stored in protesterdemand or stateresponse
  ][, unique(.SD)
    
  # Adding ids that don't have either protester_demand or state_response
  # and adding actions that didn't happen in each protest
  ][, `:=`(action_occur = TRUE,
           actions = str_c(variable," - ",actions))
  ][, !c("variable")
  ][, merge(.SD,
            CJ(id = unique(ProtestClean$id),
               actions = unique(actions)),
            by = c("id", "actions"), all = TRUE)
  ][is.na(action_occur), action_occur := FALSE
  ][, c("action_source", "actions") := tstrsplit(actions, split = " - ", fixed = TRUE)
    
  # Adding the other variables to have back the data complete
  ][, merge(.SD, ProtestClean[, !c("protesterviolence")],
            by = "id", all = TRUE)
  ][, .SD, .SDcols = !patterns("^protesterdemand|^stateresponse")]


```

</br>

## 2.3. Result

After applying the changes we can see that currently all the columns have less
than 5% of missing values.

```{r}

  ProtestCleanTidy[, lapply(.SD, function(x) mean(is.na(x)))
  ][, id := 1
  ][, melt(.SD, id.vars = "id", 
           variable.name = "Variables",
           value.name = "# Missing")
  ][, `:=`(Variables = fct_reorder(Variables, `# Missing`, sum))] |>
  ggplot(aes(`# Missing`, `Variables`))+
  geom_blank(aes(x = `# Missing` *1.15))+
  geom_col(fill = "forestgreen")+
  geom_text(aes(label = percent(`# Missing`, accuracy = 0.01)),
            hjust = -0.3)+
  scale_x_continuous(labels = percent_format(accuracy = 0.01))+
  labs(title = "Proportions of missing\nvalues per variable",
       x = "% Of Missing Values")+
  theme(axis.text = element_text(size = 15),
        axis.title = element_text(size = 16, face = "bold"),
        strip.text = element_text(size = 16),
        plot.title = element_text(size = 25, face = "bold",
                                  hjust = 0.5, margin = margin(b = 40)))

```

</br>

To have better perspective how does the data look like here is an example.

```{r}

set.seed(14)

ProtestCleanTidy[id == sample(id, 1), 
                 .(id = as.character(id), 
                   country, participants_range, 
                   start_date = format(start_date,"%m/%d/%y"),
                   end_date = format(end_date,"%m/%d/%y"),
                   action_source, actions, action_occur)] |>
  style_table()

```

</br>

# 3. Adding new variables

To get the best result in the data exploration part could be important to transform the data to get some new figure that can make easier to find some interesting relations.

</br>

## 3.1. Adding time fetures

Each protest has a time range and I think it would interesting to know:

- How long was each protest?
- Did the protest took place during a weekend?
- Did the protest took place during a holiday?

To extract that information we will need to apply some data manipulations and to answer the last one we need to get some information from a web page by using web scraping techniques as follow.

```{r, eval=FALSE}

# Getting the link to each country holidays table
HolidaysHomePageTable <- 
  read_html("https://www.officeholidays.com/countries") |>
  html_elements(xpath = '//li/a[i[starts-with(@class,"sprite")]]') |>
  (\(x) data.table(country = html_text(x) |>
                     str_match("\\w.+\\w$")|>
                     as.vector(),
                   link = html_attr(x,"href")
        )[country %chin% unique(ProtestCleanTidy[["country"]])])()


# Saving the table of each continent in a list
# lapply didn't work for some reason
NumberCountrytoScrap <- nrow(HolidaysHomePageTable)
ListToFill <- vector("list", length = NumberCountrytoScrap)

for(i in seq_len(NumberCountrytoScrap)){
  
  ListToFill[[i]] <-
    read_html(HolidaysHomePageTable[["link"]][i]) |>
    html_table(header = TRUE) |>
    (\(LIST) as.data.table(LIST[[1]])[,c("Date")])() |>
    (\(DT) DT[, country := 
                HolidaysHomePageTable[["country"]][i]][])()
  
  Sys.sleep(0.5)
}


# Saving the information as a table and page just shows the
# holidays of each country in the current year need to repeat
# each day in each year of the data
CountriesHolidays <-
  rbindlist(ListToFill, use.names = TRUE
  )[, id := .I
  ][CJ(id = id,
       year = range(ProtestCleanTidy[["year"]]) |> (\(x) x[1]:x[2])()),
    on = "id"
  ][, `:=`(Date = str_c(year," ",Date),
           during_holiday = TRUE,
           id = NULL,
           year = NULL)
  ][, Date := ymd(Date)]

```

```{r include=FALSE}
CountriesHolidays <- fread("Raw-data/countries-holidays.csv")
```

</br>

After getting the holidays we have all we need to the create the variable with the next code.

```{r}

ProtestTidyDates <-
  
  # Selecting just critical columns to use less memory
  ProtestCleanTidy[, unique(.SD),
                 .SDcols = c("id","country","start_date","end_date")
                 
  # Calculate protest duration
  ][, duration := difftime(end_date, start_date,
                            units = "days") |> as.double()+1
  
  # Getting a row of day of each protest so DT gets longer
  ][, .(Date = seq.Date(start_date,  end_date, by = "day")),
    by = c("id","country","duration")
    
  # Testing weekends and holidays each day
  ][, during_weekend := wday(Date) %in% c(1,7)
  ][, merge(.SD, CountriesHolidays,
            by = c("country","Date"), all.x = TRUE)
  ][country %chin% CountriesHolidays[, unique(country)], 
    during_holiday := FALSE
  
  # Taking the data back to the original format
  ][,.(during_weekend = sum(during_weekend) > 0,
       during_holiday = sum(during_holiday) > 0),
    by = c("id","duration")
  ][ProtestCleanTidy, on = "id"]

```


## 3.2. Adding political information

Many protests start for economic reasons that affect society in each country. To measure that we can use two indicators from **The World Bank**. The first one is the [GDP per capita (current US$)](https://data.worldbank.org/indicator/NY.GDP.PCAP.CD?most_recent_year_desc=true) to measure how much money people have and [Gini index](https://data.worldbank.org/indicator/SI.POV.GINI?most_recent_year_desc=true) to measure that money is distributed.

```{r}

CountryIncomeGroup <-
  fread("Raw-data/country-income-classification.csv",
        header = TRUE, 
        select = c("TableName","IncomeGroup")
  )[! IncomeGroup %like% "\\w", 
    IncomeGroup := NA_character_]

CountryIndex <-
  c("Raw-data/GDP-PCAP.csv",
    "Raw-data/GINI-INDEX.csv") |>
  lapply(read_country_index) |> 
  rbindlist() |>
  dcast(`Country Name`+ Year ~ `Indicator Name`, 
        value.var = "Index")


EuropeMissingCountries <-  
  c("Yugoslavia", "Serbia and Montenegro",
    "Kosovo","Germany East","Czechoslovakia")


ProtestTidy <-
  CountryIndex[CountryIncomeGroup, 
               on = c("Country Name" = "TableName")
  ][, Year := as.integer(Year)
  ][ProtestTidyDates,
    on = c("Country Name" = "country",
           "Year" = "year")
  ][, setnames(.SD,"Country Name","country")
  ][!country %chin% EuropeMissingCountries, 
    continent := countrycode(country, 
                             origin = "country.name",
                             destination = "continent")
  ][country %chin% EuropeMissingCountries, 
    continent := "Europe"]


```


# 2. Data exploration

```{r}
#g <-
  copy(ProtestTidy)[,`:=`(action_occur = as.double(action_occur),
                          actions = paste0(fifelse(action_source %like% "^p",
                                                   "P - ", "S - "),
                                           actions))
  ][country  == "Haiti", 
    dcast(.SD, id ~ actions, value.var = "action_occur")
  ][, !c("id")] |>
  correlation() |>
  summary() |>
  plot()+
  theme(axis.text.x = element_text(angle = 90, size = 14),
        axis.text.y = element_text(size = 14))

ProtestTidy[actions == "accomodation",
                      .(pct_accomodation = mean(action_occur)),
                      .(participants_range, country)] |>
  lm(formula = pct_accomodation ~ participants_range) |>
  moderndive::get_regression_table()

```


## 2.1. Which country have more protests?

In next chart we can see that the countries with more protests comes from Europe. Together, they sum 12.6% of protest in the data. Let's focus in those countries and try to answer some questions.

```{r eval=FALSE, include=FALSE}



plot_chr_count(DATA = ProtestCleanTidy,
               id_var = "id",
               group_var = "country",
               plot_fill_var = "continent",
               plot_title = "Top 20 of Coutries with more Protests",
               plot_max = 20,
               use_cumulative_sum = TRUE)
```

## 2.2. UK Graph Analysis

```{r eval=FALSE, fig.dim=c(14,10), include=FALSE}

UKEdges <-
  ProtestCleanTidy[action_occur == TRUE & action_source == "protester_demand"
  ][, setnames(.SD, "actions", "from")
  ][ProtestCleanTidy[action_occur == TRUE & action_source == "state_response",
                     .(to = actions), id],
    on = .(id)
  ][country == "United Kingdom", 
    .(number_protests = uniqueN(id)),
    .(from,to)
  ][,unique(.SD)]

UKNodes <-
ProtestCleanTidy[country == "United Kingdom" & action_occur == TRUE,
                 .(actions,action_source)
  ][, unique(.SD)]


UKgraph <- graph_from_data_frame(d = UKEdges, vertices = UKNodes)

set.seed(1)

ggraph(UKgraph, layout = "with_fr")+
  geom_edge_link(aes(alpha = number_protests,edge_width = number_protests))+
  geom_node_point(aes(color = action_source), size = 8)+
  geom_node_text(aes(label = name), vjust = 2, size = 6)+
  scale_color_brewer(palette = "Dark2")+
  labs(title = "Graph of UK Protests")+
  theme_void()+
  theme(legend.position = "left",
        legend.title = element_text(face = "bold", size = 15),
        legend.text = element_text(size = 15),
        plot.title = element_text(face = "bold", size = 20, hjust = 0.5))

```
